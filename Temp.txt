Below is a worked-through blueprint for a UV-managed Python monorepo that now contains several reusable libraries (packages) and ~10 deployable apps.  You can copy-paste the snippets as-is and adapt names/versions later.


---

1 Repository layout

repo-root/
│
├── pyproject.toml          # ← workspace root (not published)
├── uv.lock                 # single, deterministic lockfile
│
├── packages/               # shared libraries
│   ├── common/
│   │   ├── pyproject.toml
│   │   └── src/myco_common/…
│   └── data_models/
│       ├── pyproject.toml
│       └── src/myco_data_models/…
│
├── apps/                   # runnable deliverables
│   ├── ingestion/
│   │   ├── pyproject.toml
│   │   └── src/ingest_app/__main__.py
│   ├── reporting/
│   │   └── …
│   └── … eight more …
│
├── configs/                # YAML, JSON, env files
├── scripts/                # tiny helper shell/Python scripts
└── .gitlab-ci.yml

Why this works

src/ layout keeps import paths predictable.

Each package/app is an independent PEP 621 project so you can publish or test it alone, but the workspace gives you one lockfile and one virtualenv to keep versions consistent (a Cargo-style approach). 



---

2 Root pyproject.toml

[project]
name = "myco-workspace"      # not published – just a placeholder
version = "0.0.0"
description = "Internal workspace root"
readme = "README.md"
requires-python = ">=3.12"

[tool.uv.workspace]
# Everything listed here is part of the workspace → gets an editable install
members = [
    "packages/common",
    "packages/data_models",
    "apps/ingestion",
    "apps/reporting",
    # … add the rest …
]

[build-system]
requires = ["hatchling>=1.24"]
build-backend = "hatchling.build"

Notes

tool.uv.workspace is the only line that turns the repo into a workspace – no extra tooling needed. 

Root itself has no code; that’s fine – UV will still create .venv + uv.lock.



---

3 Example library package – packages/common/pyproject.toml

[project]
name            = "myco-common"
version         = "0.3.1"
description     = "Shared helpers, logging, small utilities"
requires-python = ">=3.12"
dependencies    = [
    "pydantic>=2.6",
    "loguru>=0.7",
]

[project.optional-dependencies]
test = ["pytest", "coverage[toml]"]
dev  = ["ruff", "mypy"]

[build-system]
requires = ["hatchling>=1.24"]
build-backend = "hatchling.build"

Tests live at packages/common/tests/ and run under the same workspace venv.


---

4 Example app package – apps/ingestion/pyproject.toml

[project]
name            = "ingestion-app"
version         = "1.2.0"
description     = "Batch & streaming ingestion service"
requires-python = ">=3.12"
dependencies    = [
    # internal workspace libs:
    "myco-common",            # ← resolves locally, no version pin needed
    "myco-data-models",
    # external:
    "pandas>=2.2",
    "pyyaml>=6",
    "boto3>=1.34",
]

[project.scripts]
ingest = "ingest_app.cli:main"   # uv run ingest …

[build-system]
requires = ["hatchling>=1.24"]
build-backend = "hatchling.build"

Because the workspace environment installs every member editable, local changes show up immediately during development. 


---

5 Typical developer workflow

# one-time clone
git clone git@gitlab.com:myco/data-platform.git && cd data-platform

# initialise env + install everything (first sync)
uv sync --all-packages          # or simply `uv sync` from repo root
uv run ingest --help            # runs entry point from apps/ingestion
uv run pytest -q                # tests across the whole workspace
# add a dependency to a sub-project
cd packages/common
uv add rich
# regenerate deterministic lockfile
uv lock                          # locks the whole workspace
git add uv.lock && git commit -m "feat: rich in common"

--all-packages installs every member into .venv; omit it if you want a lighter-weight env just for the one you’re editing. 


---

6 GitLab CI (.gitlab-ci.yml)

image: python:3.12-slim

stages: [lint, test, build]

variables:
  PIP_DISABLE_PIP_VERSION_CHECK: "1"
  UV_CACHE_DIR: "$CI_PROJECT_DIR/.cache/uv"  # speeds up repeated installs

cache:
  key: ${CI_PROJECT_PATH_SLUG}-uv
  paths:
    - .cache/uv
    - .venv             # re-use the workspace venv across stages

before_script:
  - pip install --upgrade uv
  # install optional dev deps (ruff/pytest/coverage) from root extra group
  - uv sync --all-packages --group dev,test

lint:
  stage: lint
  script:
    - uv run ruff check .

test:
  stage: test
  needs: [lint]
  script:
    - uv run coverage run -m pytest
    - uv run coverage xml
  artifacts:
    reports:
      cobertura: coverage.xml

build:
  stage: build
  needs: [test]
  script:
    - uv build --sdist --wheel --out dist/
  artifacts:
    paths:
      - dist/

What this does

Uses a single cached .venv for all jobs → faster pipelines.

uv sync installs the entire workspace once, in editable mode.

For real releases you can add a publish stage that pushes wheels to GitLab Package Registry or PyPI via uv publish.



---

7 Pro tips & patterns

Need	Suggestion

Consistent version bumps across all 10 apps	Use semantic-release or hatch version in the root job; tag once, update every member’s version.
Isolated container builds	In each Dockerfile: COPY ./uv.lock ./ and RUN uv sync --all-packages --no-editable --no-dev.
Code ownership	Put a CODEOWNERS file per top-level folder (packages/*, apps/*) so merge requests auto-tag correct reviewers.
Typed public API	Keep the shared packages fully type-checked (Mypy strict), apps can be more relaxed.
Gradual migration	You can leave legacy “loose” scripts under scripts/ – as they stabilise, promote them to apps/….



---

Recap

Workspace root + member pyproject.toml gives you one lockfile, one venv.

UV commands (sync, lock, run) work on the whole repo or a single package with --package.

GitLab CI becomes extremely small – no need for Poetry or pip-tools, just uv.


With this structure you can keep scaling the monorepo without losing dependency sanity or CI speed. Happy hacking!

